version: "3.9"

services:
  # OpenFlowコントローラ (RYU)
  controller:
    build:
      context: .
      dockerfile_inline: |
        FROM python:3.9-slim
        RUN apt-get update && \
            apt-get install -y iproute2 iputils-ping tcpdump gcc && \
            pip3 install --no-cache-dir 'setuptools<58.0.0' && \
            pip3 install --no-cache-dir 'eventlet!=0.30.3,<0.31' && \
            pip3 install --no-cache-dir ryu && \
            apt-get remove -y gcc && \
            apt-get autoremove -y && \
            rm -rf /var/lib/apt/lists/*

        RUN mkdir -p /ryu-apps
        COPY <<'PYEOF' /ryu-apps/simple_switch_13.py
        from ryu.base import app_manager
        from ryu.controller import ofp_event
        from ryu.controller.handler import CONFIG_DISPATCHER, MAIN_DISPATCHER
        from ryu.controller.handler import set_ev_cls
        from ryu.ofproto import ofproto_v1_3
        from ryu.lib.packet import packet, ethernet, ether_types

        class SimpleSwitch13(app_manager.RyuApp):
            OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]

            def __init__(self, *args, **kwargs):
                super(SimpleSwitch13, self).__init__(*args, **kwargs)
                self.mac_to_port = {}

            @set_ev_cls(ofp_event.EventOFPSwitchFeatures, CONFIG_DISPATCHER)
            def switch_features_handler(self, ev):
                datapath = ev.msg.datapath
                ofproto = datapath.ofproto
                parser = datapath.ofproto_parser
                match = parser.OFPMatch()
                actions = [parser.OFPActionOutput(ofproto.OFPP_CONTROLLER,
                                                  ofproto.OFPCML_NO_BUFFER)]
                self.add_flow(datapath, 0, match, actions)
                self.logger.info("Switch connected: %s", datapath.id)

            def add_flow(self, datapath, priority, match, actions, buffer_id=None):
                ofproto = datapath.ofproto
                parser = datapath.ofproto_parser
                inst = [parser.OFPInstructionActions(ofproto.OFPIT_APPLY_ACTIONS, actions)]
                if buffer_id:
                    mod = parser.OFPFlowMod(datapath=datapath, buffer_id=buffer_id,
                                            priority=priority, match=match, instructions=inst)
                else:
                    mod = parser.OFPFlowMod(datapath=datapath, priority=priority,
                                            match=match, instructions=inst)
                datapath.send_msg(mod)

            @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)
            def _packet_in_handler(self, ev):
                msg = ev.msg
                datapath = msg.datapath
                ofproto = datapath.ofproto
                parser = datapath.ofproto_parser
                in_port = msg.match['in_port']
                pkt = packet.Packet(msg.data)
                eth = pkt.get_protocols(ethernet.ethernet)[0]
                if eth.ethertype == ether_types.ETH_TYPE_LLDP:
                    return
                dst = eth.dst
                src = eth.src
                dpid = datapath.id
                self.mac_to_port.setdefault(dpid, {})
                self.logger.info("packet in %s %s %s %s", dpid, src, dst, in_port)
                self.mac_to_port[dpid][src] = in_port
                if dst in self.mac_to_port[dpid]:
                    out_port = self.mac_to_port[dpid][dst]
                else:
                    out_port = ofproto.OFPP_FLOOD
                actions = [parser.OFPActionOutput(out_port)]
                if out_port != ofproto.OFPP_FLOOD:
                    match = parser.OFPMatch(in_port=in_port, eth_dst=dst, eth_src=src)
                    if msg.buffer_id != ofproto.OFP_NO_BUFFER:
                        self.add_flow(datapath, 1, match, actions, msg.buffer_id)
                        return
                    else:
                        self.add_flow(datapath, 1, match, actions)
                data = None
                if msg.buffer_id == ofproto.OFP_NO_BUFFER:
                    data = msg.data
                out = parser.OFPPacketOut(datapath=datapath, buffer_id=msg.buffer_id,
                                          in_port=in_port, actions=actions, data=data)
                datapath.send_msg(out)
        PYEOF

        COPY <<'EOF' /start.sh
        #!/bin/bash
        echo "Starting RYU Controller..."
        ryu-manager --verbose /ryu-apps/simple_switch_13.py
        EOF
        RUN chmod +x /start.sh

    container_name: controller
    privileged: true
    network_mode: none
    command: /start.sh

  # OpenFlow Switch (OVS)
  ovs:
    build:
      context: .
      dockerfile_inline: |
        FROM ubuntu:22.04
        RUN apt-get update && \
            apt-get install -y openvswitch-switch iproute2 iputils-ping tcpdump && \
            rm -rf /var/lib/apt/lists/*

        COPY <<'EOF' /start-ovs.sh
        #!/bin/bash
        set -e
        mkdir -p /var/run/openvswitch
        if [ ! -f /etc/openvswitch/conf.db ]; then
          ovsdb-tool create /etc/openvswitch/conf.db /usr/share/openvswitch/vswitch.ovsschema
        fi
        ovsdb-server --remote=punix:/var/run/openvswitch/db.sock \
                     --remote=db:Open_vSwitch,Open_vSwitch,manager_options \
                     --pidfile --detach
        ovs-vsctl --no-wait init || true
        ovs-vswitchd --pidfile --detach --log-file
        sleep 2
        ovs-vsctl add-br br0
        ovs-vsctl set bridge br0 protocols=OpenFlow13
        echo "OVS started successfully"
        ovs-vsctl show
        exec sleep infinity
        EOF
        RUN chmod +x /start-ovs.sh

    container_name: ovs
    privileged: true
    network_mode: none
    command: /start-ovs.sh

  # Host1 (VLAN 10)
  host1:
    build:
      context: .
      dockerfile_inline: |
        FROM ubuntu:22.04
        RUN apt-get update && \
            apt-get install -y iproute2 iputils-ping tcpdump vlan && \
            rm -rf /var/lib/apt/lists/*

        COPY <<'EOF' /start.sh
        #!/bin/bash
        echo "Waiting for network interface..."
        for i in {1..30}; do
          if [ -e /sys/class/net/eth0 ]; then
            echo "eth0 found!"
            break
          fi
          sleep 1
        done
        if [ ! -e /sys/class/net/eth0 ]; then
          echo "eth0 not found, entering sleep mode"
          exec sleep infinity
        fi
        modprobe 8021q || true
        ip link add link eth0 name eth0.10 type vlan id 10
        ip addr add 192.168.10.1/24 dev eth0.10
        ip link set eth0 up
        ip link set eth0.10 up
        echo "Host1 (VLAN 10) configured"
        ip addr show
        exec sleep infinity
        EOF
        RUN chmod +x /start.sh

    container_name: host1
    privileged: true
    network_mode: none
    cap_add:
      - NET_ADMIN
    command: /start.sh

  # Host2 (VLAN 20)
  host2:
    build:
      context: .
      dockerfile_inline: |
        FROM ubuntu:22.04
        RUN apt-get update && \
            apt-get install -y iproute2 iputils-ping tcpdump vlan && \
            rm -rf /var/lib/apt/lists/*

        COPY <<'EOF' /start.sh
        #!/bin/bash
        echo "Waiting for network interface..."
        for i in {1..30}; do
          if [ -e /sys/class/net/eth0 ]; then
            echo "eth0 found!"
            break
          fi
          sleep 1
        done
        if [ ! -e /sys/class/net/eth0 ]; then
          echo "eth0 not found, entering sleep mode"
          exec sleep infinity
        fi
        modprobe 8021q || true
        ip link add link eth0 name eth0.20 type vlan id 20
        ip addr add 192.168.20.1/24 dev eth0.20
        ip link set eth0 up
        ip link set eth0.20 up
        echo "Host2 (VLAN 20) configured"
        ip addr show
        exec sleep infinity
        EOF
        RUN chmod +x /start.sh

    container_name: host2
    privileged: true
    network_mode: none
    cap_add:
      - NET_ADMIN
    command: /start.sh

  # Host3 (Link Aggregation)
  host3:
    build:
      context: .
      dockerfile_inline: |
        FROM ubuntu:22.04
        RUN apt-get update && \
            apt-get install -y iproute2 iputils-ping tcpdump ifenslave && \
            rm -rf /var/lib/apt/lists/*

        COPY <<'EOF' /start.sh
        #!/bin/bash
        echo "Waiting for network interfaces..."
        for i in {1..30}; do
          if [ -e /sys/class/net/eth0 ] && [ -e /sys/class/net/eth1 ]; then
            echo "eth0 and eth1 found!"
            break
          fi
          sleep 1
        done
        if [ ! -e /sys/class/net/eth0 ] || [ ! -e /sys/class/net/eth1 ]; then
          echo "Interfaces not found, entering sleep mode"
          exec sleep infinity
        fi
        modprobe bonding || true
        ip link add bond0 type bond mode 802.3ad
        ip link set eth0 master bond0
        ip link set eth1 master bond0
        ip addr add 192.168.30.1/24 dev bond0
        ip link set eth0 up
        ip link set eth1 up
        ip link set bond0 up
        echo "Host3 (Link Aggregation) configured"
        ip addr show
        cat /proc/net/bonding/bond0 || true
        exec sleep infinity
        EOF
        RUN chmod +x /start.sh

    container_name: host3
    privileged: true
    network_mode: none
    cap_add:
      - NET_ADMIN
    command: /start.sh

  # Router1 (VRRP Master)
  router1:
    build:
      context: .
      dockerfile_inline: |
        FROM ubuntu:22.04
        RUN apt-get update && \
            apt-get install -y iproute2 iputils-ping keepalived tcpdump && \
            rm -rf /var/lib/apt/lists/*

        COPY <<'EOF' /start.sh
        #!/bin/bash
        echo "Waiting for network interface..."
        for i in {1..30}; do
          if [ -e /sys/class/net/eth0 ]; then
            echo "eth0 found!"
            break
          fi
          sleep 1
        done
        if [ ! -e /sys/class/net/eth0 ]; then
          echo "eth0 not found, entering sleep mode"
          exec sleep infinity
        fi
        mkdir -p /etc/keepalived
        cat > /etc/keepalived/keepalived.conf <<KEOF
        vrrp_instance VI_1 {
            state MASTER
            interface eth0
            virtual_router_id 51
            priority 100
            advert_int 1
            authentication {
                auth_type PASS
                auth_pass 1234
            }
            virtual_ipaddress {
                192.168.100.254/24
            }
        }
        KEOF
        ip addr add 192.168.100.1/24 dev eth0
        ip link set eth0 up
        sysctl -w net.ipv4.ip_forward=1
        sysctl -w net.ipv4.ip_nonlocal_bind=1
        echo "Router1 (VRRP Master) configured"
        ip addr show eth0
        keepalived -n -l -D
        EOF
        RUN chmod +x /start.sh

    container_name: router1
    privileged: true
    network_mode: none
    cap_add:
      - NET_ADMIN
    command: /start.sh

  # Router2 (VRRP Backup)
  router2:
    build:
      context: .
      dockerfile_inline: |
        FROM ubuntu:22.04
        RUN apt-get update && \
            apt-get install -y iproute2 iputils-ping keepalived tcpdump && \
            rm -rf /var/lib/apt/lists/*

        COPY <<'EOF' /start.sh
        #!/bin/bash
        echo "Waiting for network interface..."
        for i in {1..30}; do
          if [ -e /sys/class/net/eth0 ]; then
            echo "eth0 found!"
            break
          fi
          sleep 1
        done
        if [ ! -e /sys/class/net/eth0 ]; then
          echo "eth0 not found, entering sleep mode"
          exec sleep infinity
        fi
        mkdir -p /etc/keepalived
        cat > /etc/keepalived/keepalived.conf <<KEOF
        vrrp_instance VI_1 {
            state BACKUP
            interface eth0
            virtual_router_id 51
            priority 90
            advert_int 1
            authentication {
                auth_type PASS
                auth_pass 1234
            }
            virtual_ipaddress {
                192.168.100.254/24
            }
        }
        KEOF
        ip addr add 192.168.100.2/24 dev eth0
        ip link set eth0 up
        sysctl -w net.ipv4.ip_forward=1
        sysctl -w net.ipv4.ip_nonlocal_bind=1
        echo "Router2 (VRRP Backup) configured"
        ip addr show eth0
        keepalived -n -l -D
        EOF
        RUN chmod +x /start.sh

    container_name: router2
    privileged: true
    network_mode: none
    cap_add:
      - NET_ADMIN
    command: /start.sh